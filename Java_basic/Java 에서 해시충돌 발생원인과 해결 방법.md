

# Java 에서 해시충돌 발생원인과 해결 방법



### 해시 충돌과 원인

- 해시 자료구조에서 키 값은 해시 함수를 통해서 해시 코드로 변환됩니다 (hashCode())
- 해시 함수는 "키"를 받아서 **정수값인 해시 코드를 반환**합니다.
  - 해시 함수는 key를 받아서 정수값인 해시 코드를 반환하는데 이 때 key로 넘어오는 데이터의 수는 무한히 많을 수 있지만 반환 가능한 해시코드의 수는 정수의 범위 내입니다.
  - 위의 부분이 해시 충돌의 원인입니다. 
  - 이로 인해서 서로 다른 키 값이 같은 해시 코드를 반환하는 경우가 생깁니다.
  - 이를 해시 충돌이라고 합니다.



## 해쉬 충돌의 해결방법

자바에서는 해시 충돌을 체이닝(chainning), 개방 주소법(open addressing)을 통해서 해결합니다.

> [!TIP]
>
> #### 연결 리스트
>
> ####  노드가 다음 노드를 가리키는 포인터를 통해 **순차적으로 노드들이 연결된 구조**입니다.
>
> - 탐색 시간 복잡도 : O(n)
> - 삽입/시간 복잡도 : O(1) [위치를 알고 있는 경우]
>
> **순차탐색**
>
> - 리스트의 안에 있는 데이터를 찾기위해 처음부터 끝까지 하나씩 탐색하는것
>
> #### 이진 탐색 트리
>
> - **모든 노드는 유일한 키를 가지고, 루트노드의 왼쪽 서브트리는 해당 노드보다 작은 값, 오른쪽 서브트리는 큰 값**을 가지는 구조입니다.



### 1. Chainning (체이닝)

- **중복된 해시 값이 있을 경우 해당 슬롯을 연결 리스트로 저장**합니다.

- 이 방식은 주로 자바의 HashMap이나 HashSet에서 사용합니다.

- 동일한 해시 값으로 인해 충돌이 발생하면, 해당 해시 값의 버킷에 **연결 리스트를 사용하여 여러 값을 저장합니다**. (Java 8부터는 트리로 변환 가능)

  ![image-20241209234812016](https://raw.githubusercontent.com/CUCU7103/save-image-repo/main/image/image-20241209234812016.png)

- 장점

  - 연결 리스트에 계속해서 값을 추가할 수 있습니다.

  - 버킷이 꽉 차더라도 연결리스트로 계속 늘려가기에 데이터의 주소값은 바뀌지 않음

  - 충돌이 발생하면 해당 버킷에 새로운 요소를 추가하기 위해

     

    연결 리스트 또는 트리를 동적으로 생성하여 충돌된 항목들을 저장

    합니다.

    - 이를 통해 추가적인 해시 테이블의 크기를 확장할 필요 없이 충돌된 데이터를 처리할 수 있습니다.

- 단점

  - 연결 리스트를 순차적으로 탐색하여 값을 찾아야 하기 때문에 탐색시간이 오래 걸려 O(n)의 시간 복잡도를 가질 수 있습니다.

- 개선사항

  - 이러한 체이닝의 단점을 극복하기 위해 연결 리스트가 일정 길이 이상(기본적으로 8 이상)이 되면, 해당 연결 리스트를 **<u>이진 탐색 트리로 변환하여 최악의 경우에도 시간 복잡도가 O(log n)으로 줄어들게 최적화했습니다.</u>**
  - 이 방식으로 긴 연결 리스트에서 탐색하는 성능 문제를 완화할 수 있습니다.



### 2. Open addressing

- **충돌이 발생할 경우 다른 버킷에 데이터를 저장하는 방법입니다.**

  -  즉 충돌이 일어난 키 값을 비어 있는 다른 주소를 찾아 저장하는 방법입니다.

  -  모든 요소를 해시 테이블(혹은 배열) 자체에 저장하기 때문에 테이블(배열)의 크기는 키의 개수보다 반드시 크거나 같아야 합니다.

     ![image-20241210000454319](https://raw.githubusercontent.com/CUCU7103/save-image-repo/main/image/image-20241210000454319.png)

> [!NOTE]
>
> #### 기본연산
>
> 1) insert(key)
>    - 빈 슬롯을 찾을 때까지 계속 조사(probing)하고 빈 slot을 찾으면 키를 삽입합니다.
>
> 2) search(key)
>    - slot의 key가 찾고자 하는 key와 동일하거나 빈 slot에 도달할 때까지 계속 조사합니다. 
>
> 3) delete(key)
>
>    - 삭제된 키의 슬롯에 삭제 표시를 한다.
>
>    - 삽입은 삭제된 슬롯에 삽입할 수 있지만 검색은 삭제된 슬롯에서 멈추지 않는다.



이때 다른 버킷을 어떻게 찾느냐에 따라 방법이 나뉘어 집니다.

> [!NOTE]
>
> 1. 선형탐색
> 2. 제곱탐색
> 3. 이중해싱



#### 1. 선형탐색

![7](https://github.com/user-attachments/assets/931fa7ae-8651-4501-a09d-4d1dddc0ef57)


![8](https://github.com/user-attachments/assets/6762fd06-c202-4bf9-8916-55ce2433701c)


- 해시 충돌시에 n칸을 건너뛴 버킷에 저장하는 방식입니다.

  - 장점  
    - 구조가 간단하고 캐시의 효율이 높음

  - 단점 
    -  최악의 경우 해시테이블 전체를 검색해야 하는 상황이 발생함.



#### 2. 제곱탐색

- 충돌이 일어난 해시의 제곱을 한 해시에 데이터를 저장

![9](https://github.com/user-attachments/assets/a5f9d40c-ee28-4fa8-932a-45a6866ae872)


#### 3. 이중해싱

- 해시 충돌시 다른 해시함수를 한번 더 적용한 결과를 이용

![10](https://github.com/user-attachments/assets/0b0a8b87-46e9-4b0b-8f03-9c69cfe91381)
