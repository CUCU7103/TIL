# HashMap vs ConcurrentHashMap vs HashTable

#### 모두 자바의 Map 인터페이스를 구현한 클래스들로, 키-값 쌍의 데이터를 저장하고 관리하는데 사용되어집니다.

## HashMap

- key 와 value에 null을 허용합니다.
- HashMap은 동기화를 지원하지 않기 때문에 다중 스레드 환경에서는 동시성 이슈가 발생할 수 있다
- 동기화 처리를 하지 않기 때문에 데이터 탐색 속도는 빠르지만, 신뢰성과 안정성이 떨어진다.



> [!NOTE]
>
> Synchronized가 느린 이유
>
> synchronized는 멀티스레드 환경에서 동시성 문제를 해결하기 위해 사용되어집니다.
>
> - 하지만 sychronized는 blocking 방식으로 동작하기에 `synchronized` 블록에 진입한 스레드는 해당 블록이 끝날 때까지 락을 유지하므로, 다른 스레드들은 대기해야 합니다.
>   - 락은 특정 자원을 보호하기 위해 스레드가 해당 자원에 대한 접근하는 것을 제한합니다.
> - 락이 걸려 있는 동안 다른 스레드들은 해당 자원에 접근할 수 없고, 락이 해제될 때까지 대기해야 합니다.
> - 또한 락 기반 접근에서는 락을 획득하고 해제하는 데 시간이 소요됩니다.
> - 이로 인해 병목 현상이 발생하여 성능이 저하된다는 단점이 있습니다.
> - 또한 여러 스레드가 서로 다른 자원을 기다며 무한 대기 상태에 빠지는 데드락 상황이 발생할 수가 있습니다



## HashTable

- Key Value에 null을 허용하지 않고, 동기화를 보장한다.

- HashTable은 주요 메소드(`get`, `put`, `remove` 등)마다 `synchronized` 키워드가 붙어 있습니다.

- **즉, 메소드 호출 시 HashTable 객체 전체에 대해 lock(잠금)이 걸립니다**.

- HashTable은 동기화를 통해 한 순간에 **오직 하나의 스레드만** 데이터를 읽거나 수정할 수 있습니다.

- 여러 스레드가 동시에 `put`이나 `get`을 호출하면, 나머지 스레드들은 현재 실행 중인 작업이 끝날 때까지 **대기 상태**가 됩니다.

- 동기화 단위가 크기 때문에 다수의 스레드가 동시에 접근할 경우 성능 병목이 발생할 수 있습니다.

  



## ConCurrentHashMap

- Key Value에 null을 허용하지 않으며 동기화를 보장한다.
- HashMap의 동기화 문제를 보완하기 위해 추가됨
- 동기화 처리 시, Hashtable과 다르게 조작하는 **버킷(index)에 대해서만 락**을 걸기 때문에, 같은 멀티 쓰레드 환경에서 사용하더라도 **HashTable 대비 속도가 빠르다.**
- 내부적으로 데이터를 **버킷(bucket)**이라는 단위로 나누고, 각 버킷은 독립적으로 관리됩니다.
  - **동시에 읽기/쓰기 가능**
    - 특정 키에 대한 `put` 작업이 진행 중이라도, 다른 키에 대해 **읽기/쓰기 작업은 동시에 가능**합니다.
    - 병렬 작업이 가능하므로 다중 스레드 환경에서 성능이 우수합니다.



![image-20241117180133484](https://raw.githubusercontent.com/CUCU7103/typora_images/main/image/image-20241117180133484.png?token=AZT7RR4VYIVNQTEYZA5IQE3HHGYSW)

