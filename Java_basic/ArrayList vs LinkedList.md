# ArrayList vs LinkedList

> [!TIP]
>
> ## 시간복잡도
>
> 
>
> 알고리즘이 실행되는데 걸리는 시간을 입력 크기에 따라서 표현한 것입니다.
>
> #### 빅오 표기법의 일반적인 표현:
>
> 
>
> - **O(1)**: 입력 크기에 관계없이 항상 일정한 시간이 걸리는 경우(상수 시간).
>
> - **O(log n)**: 입력 크기 n에 대해 로그 시간만큼 실행 시간이 걸리는 경우(로그 시간).
>
> - **O(n)**: 입력 크기 n에 비례해 실행 시간이 증가하는 경우(선형 시간).
>
> - **O(n^2)**: 입력 크기 n에 대해 실행 시간이 제곱에 비례해 증가하는 경우(이차 시간).
>
>   ![image](https://github.com/user-attachments/assets/6db36190-9a50-4461-b58d-80b932a7e37f)
>
>   ![image](https://github.com/user-attachments/assets/d7295693-e504-4c56-a015-c9751cfc4406)
> 




### ArrayList
<br>
ArrayList는 배열 기반의 리스트 구현체 입니다.

- 내부적으로 동적 배열(dynamic array)을 사용해서 데이터를 저장합니다.
- 인덱스를 사용하여 요소에 접근하기 때문에 조회(검색) 속도가 매우 빠릅니다. (O(1))
- 요소를 추가할 때, 배열의 크기가 부족하면 자동으로 더 큰 배열을 생성하고 기존 데이터를 복사합니다. 이 과정은 드물게 O(n)이지만, 대부분의 경우 맨 뒤 추가는 amortized O(1)입니다.
- 중간이나 앞에 요소를 추가/삭제할 때는 해당 위치 이후의 모든 요소를 한 칸씩 이동시켜야 하므로 O(n)의 시간이 소요됩니다.

![image](https://github.com/user-attachments/assets/35507c89-5d44-4f9b-85a1-5d1e764fd6ee)




### LinkedList 

- 자바의 LinkedList는 ArrayList와 마찬가지로 인덱스로 접근이 가능하지만, 내부 구조가 완전히 다릅니다.
- **이중 연결 리스트(doubly linked list)** 구조로, 각 노드는 이전 노드와 다음 노드에 대한 포인터를 가지고 있습니다.
- 임의의 위치에 요소를 추가/삭제할 때, 해당 위치의 노드를 찾는 데 O(n)이 소요됩니다. 하지만 노드를 찾고 나면 실제 추가/삭제는 포인터만 바꾸면 되므로 O(1)입니다.
- 맨 앞(head)이나 맨 뒤(tail)에서의 추가/삭제는 포인터 참조만 변경하면 되므로 O(1)입니다.
  
![image](https://github.com/user-attachments/assets/af324568-78aa-4a9b-abfe-269d98818216)
![image](https://github.com/user-attachments/assets/bae03e61-74dd-4fae-a1e8-3b2283401dc7)




### 추가 , 삭제 작업

| 작업                   | ArrayList                             | LinkedList                                                      |
|------------------------|---------------------------------------|-----------------------------------------------------------------|
| **맨 뒤에 추가**       | Amortized O(1) (용량 초과시 O(n))     | O(1) (tail 포인터가 있을 때)                                    |
| **중간/앞에 추가/삭제**| 위치 찾기 O(1), 데이터 이동 O(n)       | 위치 찾기 O(n), 추가/삭제 O(1) (포인터만 변경)                   |
| **맨 앞에 추가/삭제**  | 위치 찾기 O(1), 데이터 이동 O(n)       | O(1) (head 포인터가 있을 때)                                    |



### 인덱스 조회 

- ArrayList: 
  - 배열에 인덱스를 사용해서 값을 O(1)로 찾을 수 있음 

- linkedList: 
  - 노드를 인덱스 수 만큼 이동해야함 O(n)



### 검색

- ArrayList: 
  - 데이터를 찾을 때 까지 배열을 순회 O(n) 

- linkedList: 
  - 데이터를 찾을 때 까지 노드를 순회 O(n)



### 사용시점

- LinkedList는 조회시 시간 복잡도가 O(n), ArrayList는  조회 시 시간복잡도가 O(1)으로 매우 빠르기에 조회위주의 작업이 많다면 ArrayList를 사용하는것이 유리합니다.
- 반면에 삽입, 삭제가 빈번하게 일어나는 경우라면 LinkedList의 삽입, 삭제의 시간 복잡도는 O(1)이기에 LinkedList를 사용하는 것이 유리합니다.







