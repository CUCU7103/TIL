# ArrayList vs LinkedList

> [!TIP]
>
> ## 시간복잡도
>
> 
>
> 알고리즘이 실행되는데 걸리는 시간을 입력 크기에 따라서 표현한 것입니다.
>
> #### 빅오 표기법의 일반적인 표현:
>
> 
>
> - **O(1)**: 입력 크기에 관계없이 항상 일정한 시간이 걸리는 경우(상수 시간).
>
> - **O(log n)**: 입력 크기 n에 대해 로그 시간만큼 실행 시간이 걸리는 경우(로그 시간).
>
> - **O(n)**: 입력 크기 n에 비례해 실행 시간이 증가하는 경우(선형 시간).
>
> - **O(n^2)**: 입력 크기 n에 대해 실행 시간이 제곱에 비례해 증가하는 경우(이차 시간).
>
>   ![image](https://github.com/user-attachments/assets/6db36190-9a50-4461-b58d-80b932a7e37f)
>
>   ![image](https://github.com/user-attachments/assets/d7295693-e504-4c56-a015-c9751cfc4406)
> 




### ArrayList
<br>
ArrayList는 배열 기반의 리스트 구현체 입니다.

- 내부적으로 동적 배열(dynamic array)을 사용해서 데이터를 저장합니다.
- 인덱스를 사용하여 요소에 접근하기 때문에 조회(검색) 속도가 매우 빠릅니다. (O(1))
- 요소를 추가할 때, 배열의 크기가 부족하면 자동으로 더 큰 배열을 생성하고 기존 데이터를 복사합니다. 이 과정은 드물게 O(n)이지만, 대부분의 경우 맨 뒤 추가는 amortized O(1)입니다.
- 중간이나 앞에 요소를 추가/삭제할 때는 해당 위치 이후의 모든 요소를 한 칸씩 이동시켜야 하므로 O(n)의 시간이 소요됩니다.

![image](https://github.com/user-attachments/assets/35507c89-5d44-4f9b-85a1-5d1e764fd6ee)




### LinkedList 

- 자바의 LinkedList는 ArrayList와 마찬가지로 인덱스로 접근이 가능하지만, 내부 구조가 완전히 다릅니다.
- **이중 연결 리스트(doubly linked list)** 구조로, 각 노드는 이전 노드와 다음 노드에 대한 포인터를 가지고 있습니다.
- 임의의 위치에 요소를 추가/삭제할 때, 해당 위치의 노드를 찾는 데 O(n)이 소요됩니다. 하지만 노드를 찾고 나면 실제 추가/삭제는 포인터만 바꾸면 되므로 O(1)입니다.
- 맨 앞(head)이나 맨 뒤(tail)에서의 추가/삭제는 포인터 참조만 변경하면 되므로 O(1)입니다.
  
![image](https://github.com/user-attachments/assets/af324568-78aa-4a9b-abfe-269d98818216)
![image](https://github.com/user-attachments/assets/bae03e61-74dd-4fae-a1e8-3b2283401dc7)




### 추가 , 삭제 작업

| 작업                   | ArrayList                             | LinkedList                                                      |
|------------------------|---------------------------------------|-----------------------------------------------------------------|
| **맨 뒤에 추가**       | Amortized O(1) (용량 초과시 O(n))     | O(1) (tail 포인터가 있을 때)                                    |
| **중간/앞에 추가/삭제**| 위치 찾기 O(1), 데이터 이동 O(n)       | 위치 찾기 O(n), 추가/삭제 O(1) (포인터만 변경)                   |
| **맨 앞에 추가/삭제**  | 위치 찾기 O(1), 데이터 이동 O(n)       | O(1) (head 포인터가 있을 때)                                    |



#### 각 작업별 시간 복잡도 설명

##### 1. 맨 뒤에 추가  
- **ArrayList**  
  - 배열의 마지막에 바로 데이터를 넣을 수 있어서 일반적으로 O(1)입니다.  
  - 하지만 내부 배열의 용량이 부족하면 더 큰 배열을 새로 만들어 모든 데이터를 복사해야 하므로 그 경우 O(n)이 됩니다.
- **LinkedList**  
  - tail 포인터가 있다면 마지막 노드 뒤에 새 노드를 연결하는 것은 포인터만 바꾸면 되어 O(1)입니다.

---

##### 2. 중간/앞에 추가/삭제  
- **ArrayList**  
  - 원하는 인덱스에 바로 접근(O(1))은 가능하지만, 해당 위치에 데이터를 추가하거나 삭제하면 그 뒤의 모든 데이터를 한 칸씩 이동(shift)해야 하므로 O(n)이 됩니다.
- **LinkedList**  
  - 삽입/삭제할 위치의 노드를 찾으려면 앞에서부터 차례로 따라가야 하기 때문에 O(n)이 소요됩니다.  
  - 하지만 위치를 찾은 후에는 포인터만 바꾸면 되므로 실제 추가/삭제 동작 자체는 O(1)입니다.

---

##### 3. 맨 앞에 추가/삭제  
- **ArrayList**  
  - 인덱스 0에 바로 접근할 수는 있지만, 데이터를 넣거나 삭제하면 모든 요소를 한 칸씩 이동시켜야 하므로 O(n)입니다.
- **LinkedList**  
  - head 포인터가 있으므로 맨 앞에 새 노드를 추가하거나 삭제할 때는 포인터만 바꿔주면 되기 때문에 O(1)입니다.

---

이처럼 ArrayList는 배열 기반 구조로 인해 데이터 이동이 필요할 때 시간이 오래 걸리고, LinkedList는 연결 구조라 포인터만 바꾸면 되므로 삽입/삭제가 빠른 차이가 있습니다.



### 인덱스 조회 

- ArrayList: 
  - 임의의 인덱스에 즉시 접근할 수 있어 조회가 O(1)입니다.
- LinkedList: 
  - 원하는 인덱스까지 앞(또는 뒤)에서부터 노드를 하나씩 따라가야 하므로 O(n)이 걸립니다.


### 검색

- ArrayList: 
  - 값을 찾을 때(예: 특정 값을 포함하는지 검사) 배열 전체를 순회해야 하므로 O(n)입니다.
- LinkedList: 
  - 값을 찾으려면 앞에서부터 노드를 하나씩 따라가야 하므로 O(n)입니다.



### 사용시점

- 데이터의 "조회(인덱스 접근)"가 빈번하다면 ArrayList가 더 효율적입니다. (예: 대량의 데이터를 자주 읽는 경우)
- 데이터의 "삽입/삭제"가 리스트의 중간이나 앞에서 자주 일어난다면 LinkedList가 더 효율적입니다. (예: 큐, 덱과 같은 자료구조 구현)
- 단, LinkedList는 인덱스 기반 접근이 느리기 때문에, 인덱스를 자주 사용하는 경우에는 적합하지 않습니다.







