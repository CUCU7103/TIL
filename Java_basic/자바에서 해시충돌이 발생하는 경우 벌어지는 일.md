

# 자바에서 해시 충돌이 발생할때 일어나는일

>자바에서 해시충돌이 발생했을때 대표적인 해시기반 자료구조인 HashMap이나 HashSet은 Chainng과  Open addressing을 사용하여 해시 충돌을 처리합니다.
> - chainng은 해시충돌이 발생한 해시 값의 버킷에 새로운 요소를 추가하기 위해 **연결 리스트 또는 트리를 동적으로 생성하여 충돌된 항목들을 저장**합니다.
> - Open addressing은 충돌이 발생할 경우 다른 버킷에 데이터를 저장하는 방식으로  해시충돌을 처리합니다.

<br>
<br>

> [!IMPORTANT]
>
> ## 자바에서의 해시코드
>
> 자바에서 해시코드는 객체의 고유한 주소 값을 해시 알고리즘을 사용하여 생성한 int 값입니다.
>
> 어플리케이션이 실행되어지는 동안 객체의 해시코드는 값은 고유합니다.
>
> 어플리케이션이 중지되었다 다시 실행되는 경우 객체의 해시코드는 값은 변할 수 있습니다.

> [!IMPORTANT]
>
> ## 시간복잡도
>
> 알고리즘이 실행되는데 걸리는 시간을 입력 크기에 따라서 표현한 것입니다.
>
> #### 빅오 표기법의 일반적인 표현:
>
> - **O(1)**: 입력 크기에 관계없이 항상 일정한 시간이 걸리는 경우(상수 시간).
>
> - **O(log n)**: 입력 크기 n에 대해 로그 시간만큼 실행 시간이 걸리는 경우(로그 시간).
>
> - **O(n)**: 입력 크기 n에 비례해 실행 시간이 증가하는 경우(선형 시간).
>
> - **O(n^2)**: 입력 크기 n에 대해 실행 시간이 제곱에 비례해 증가하는 경우(이차 시간).
>
>   ![1](https://github.com/user-attachments/assets/0a21387f-8767-4310-b3a3-6acaeed34e20)



## 해시 자료구조

> 해시는 입력된 데이터를 고정된 길이의 데이터로 변환된 값을 말합니다.
>
> - 다른 말로는 해시값 , 해시코드 , 체크섬 이라고합니다.
> - 해시는 해시함수에 의해서 생성되어집니다. 



#### 해시함수

- 주어진 데이터를 고유한 정수 값인 해시 값으로 표현해주는 함수입니다.
- KEY란 해시함수의 입력부분이며 입력 데이터 자체이거나 입력 데이터를 구분하는 값을 의미합니다.
- 해시 값(value)은 해시함수의 출력부분이며 해시, 해시코드 등의 이름으로 불리고, 해시 테이블의 인덱스가 됩니다.

![2](https://github.com/user-attachments/assets/8a6d3df9-fb4f-49d4-a1bf-82b7aa69ea7d)


#### 해시테이블 

- 해시 테이블은 데이터가 저장되는 곳으로 해시 함수를 통해 산출된 해시값을 인덱스로 하여 해당 데이터를 저장하는 곳입니다.

![3](https://github.com/user-attachments/assets/e889102b-112e-463f-828b-f517fd557b94)


- 예를 들어서 각 과일별 가격을 지정한다고 했을때 해시 테이블에 저장해야 하는 값은 각 과일의 가격이며 이를 구분하는 과일의 값은 key가 될 것입니다.
- 키 값인 과일명을 넣으면 해시함수를 통해 해쉬값을 산출하고 산출된 해쉬값이 가르키는 해시테이블의 인덱스에 과일의 가격을 저장합니다.

- 과일의 가격이 저장되는 부분 즉 데이터가 저장되는 부분을 버킷이라고 칭합니다.
- 즉 해쉬값은 key가 해쉬함수를 통해 데이터가 저장된 버킷을 가르키는 주소로 설명할 수 있습니다.

## 해쉬 충돌

- 서로 다른 key를 함수에 넣었는데 같은 해시 값으로 반환되는 경우를 말합니다.
- 해시 충돌은 해시 함수의 특성상 불가피하게 발생할 수 있으며, 이를 적절히 처리하지 않으면 해시 자료구조의 성능이 저하될 수 있습니다

### 

## 해쉬 충돌의 해결방법

자바에서는 해시 충돌을 체이닝(chainning), 오픈 어드레싱(open addressing), 재해싱(Rehashing)을 통해서 해결합니다.

> [!TIP]
>
> #### 연결 리스트
>
> - 노드가 다음 노드를 가리키는 포인터를 통해 **순차적으로 노드들이 연결된 구조**입니다.
> - 탐색 시간 복잡도 : O(n)
> - 삽입/시간 복잡도 : O(1) [위치를 알고 있는 경우]
>
> #### 순차탐색 
>
> - 리스트의 안에 있는 데이터를 찾기위해 처음부터 끝까지 하나씩 탐색하는것
>
> #### 이진 탐색 트리 
>
> - **모든 노드는 유일한 키를 가지고,  루트노드의 왼쪽 서브트리는 해당 노드보다 작은 값, 오른쪽 서브트리는 큰 값**을 가지는 구조입니다.
>
>  ![4](https://github.com/user-attachments/assets/1effa73e-3d58-479f-9b54-de127b3c9dec)




### 1. Chainning (체이닝)

- 중복된 해시 값이 있을 경우 해당 슬롯을 연결 리스트로 저장합니다.
- 이 방식은 주로 자바의 HashMap이나 HashSet에서 사용합니다.
- 동일한 해시 값으로 인해 충돌이 발생하면, 해당 해시 값의 버킷에 **연결 리스트를 사용하여 여러 값을 저장합니다**.
  - (Java 8부터는 트리로 변환 가능)

  ![5](https://github.com/user-attachments/assets/8728eaf2-5a90-45b0-bb38-d1858a5360b6)


​  ![6](https://github.com/user-attachments/assets/e822b7b0-9b34-4d01-bcbe-55e85396cee5)

- 장점
  - 연결 리스트에 계속해서 값을 추가할 수 있습니다. 
  - 버킷이 꽉 차더라도 연결리스트로 계속 늘려가기에 데이터의 주소값은 바뀌지 않음
  - 충돌이 발생하면 해당 버킷에 새로운 요소를 추가하기 위해 **연결 리스트 또는 트리를 동적으로 생성하여 충돌된 항목들을 저장**합니다. 
    - 이를 통해 추가적인 해시 테이블의 크기를 확장할 필요 없이 충돌된 데이터를 처리할 수 있습니다.



- 단점 
  - 연결 리스트를 순차적으로 탐색하여 값을 찾아야 하기 때문에 탐색시간이 오래 걸려 O(n)의 시간 복잡도를 가질 수 있습니다.



> 이러한 체이닝의 단점을 극복하기 위해 연결 리스트가 일정 길이 이상(기본적으로 8 이상)이 되면, 해당 연결 리스트를 **이진 탐색 트리로 변환하여 최악의 경우에도 시간 복잡도가 O(log n)으로 줄어들게 최적화했습니다.** 
>
> 이 방식으로 긴 연결 리스트에서 탐색하는 성능 문제를 완화할 수 있습니다.



### 2. Open addressing

- **충돌이 발생할 경우 다른 버킷에 데이터를 저장하는 방법입니다.**
- 즉 충돌이 일어난 키 값을 비어 있는 다른 주소를 찾아 저장하는 방법입니다.
  -  모든 요소를 해시 테이블 자체에 저장하기 때문에 테이블의 크기는 키의 개수보다 반드시 크거나 같아야 합니다.

> [!NOTE]
>
> #### 기본연산
>
> 1) insert(key)
>    - 빈 슬롯을 찾을 때까지 계속 조사(probing)하고 빈 slot을 찾으면 키를 삽입합니다.
>
> 2) search(key)
>    - slot의 key가 찾고자 하는 key와 동일하거나 빈 slot에 도달할 때까지 계속 조사합니다. 
>
> 3) delete(key)
>
>    - 삭제된 키의 슬롯에 삭제 표시를 한다.
>
>    - 삽입은 삭제된 슬롯에 삽입할 수 있지만 검색은 삭제된 슬롯에서 멈추지 않는다.



이때 다른 bucket을 어떻게 찾느냐에 따라 방법이 나뉘어 집니다.

> [!NOTE]
>
> 1. 선형탐색
> 2. 제곱탐색
> 3. 이중해싱



#### 1. 선형탐색

![7](https://github.com/user-attachments/assets/931fa7ae-8651-4501-a09d-4d1dddc0ef57)


![8](https://github.com/user-attachments/assets/6762fd06-c202-4bf9-8916-55ce2433701c)


- 해시 충돌시에 n칸을 건너뛴 버킷에 저장하는 방식입니다.

  - 장점  
    - 구조가 간단하고 캐시의 효율이 높음

  - 단점 
    -  최악의 경우 해시테이블 전체를 검색해야 하는 상황이 발생함.



#### 2. 제곱탐색

- 충돌이 일어난 해시의 제곱을 한 해시에 데이터를 저장

![9](https://github.com/user-attachments/assets/a5f9d40c-ee28-4fa8-932a-45a6866ae872)


#### 3. 이중해싱

- 해시 충돌시 다른 해시함수를 한번 더 적용한 결과를 이용

![10](https://github.com/user-attachments/assets/0b0a8b87-46e9-4b0b-8f03-9c69cfe91381)


## 정리

자바에서 해시충돌이 발생했을때 대표적인 해시기반 자료구조인 HashMap이나 HashSet은 Chainng과  Open addressing을 사용하여 해시 충돌을 처리합니다.

chainng은 해시충돌이 발생한 해시 값의 버킷에 새로운 요소를 추가하기 위해 **연결 리스트 또는 트리를 동적으로 생성하여 충돌된 항목들을 저장**합니다.

Open addressing은 충돌이 발생할 경우 다른 버킷에 데이터를 저장하는 방식으로  해시충돌을 처리합니다.















 
