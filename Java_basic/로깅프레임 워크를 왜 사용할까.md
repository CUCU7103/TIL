# 로깅 프레임워크를 왜 사용할까?

> [!TIP]
>
> ### 로깅 
>
> - **정보를 제공하는 일련의 기록인 로그를 생성하도록 시스템을 작성하는 활동**
> - **개발이나 운영 중 발생하는 문제점을 모니터링하거나 추적하는 데 용이합니다.**



### System.out.println() 대신 로깅 프레임워크를 사용해야 되는 이유는 다음과 같습니다.

### 1. `System.out.println()`은 단순한 출력이지만, **로깅 프레임워크는 다양한 로그 레벨을 제공**합니다.

1.  대표적인 로그 레벨로는 `TRACE`, `DEBUG`, `INFO`, `WARN`, `ERROR` 등이 있습니다.
2.  이는 **로그 메시지의 중요도에 따라 구분할 수 있고, 필요한 경우 특정 레벨 이상의 로그만 출력하거나 기록하도록 설정할 수 있습니다**.
3. 예를 들어, 개발 중에는 `DEBUG` 로그를 많이 사용하지만, 실제 프로덕션 환경에서는 `INFO` 또는 `ERROR` 수준의 로그만 기록하게 설정할 수 있습니다.

> [!TIP]
>
> ### **로그레벨** 
>
> - **로그 레벨은 로깅 시스템의 설정을 통해 지정하며, 설정된 로그 레벨 이상의 중요도를 가진 로그 메시지만 기록되어집니다.**
>
> **1) TRACE**
>
> - 가장 상세한 로그 레벨로, 애플리케이션의 실행 흐름과 디버깅 정보를 상세히 기록한다. 주로 디버깅 시에 사용된다.
>
> **2) DEBUG**
>
> - 디버깅 목적으로 사용되며, 개발 단계에서 상세한 정보를 기록한다.
> - 애플리케이션의 내부 동작을 이해하고 문제를 분석하는 데 도움을 준다.
>
> **3) INFO**
>
> - 정보성 메시지를 기록한다.
> - 애플리케이션의 주요 이벤트나 실행 상태에 대한 정보를 전달한다. 
>
> **4) WARN**
>
> - 경고성 메시지를 기록한다.
> - 예상치 못한 문제나 잠재적인 오류 상황을 알리는 메시지이다.
> - 애플리케이션이 정상적으로 동작하지만 주의가 필요한 상황을 알려준다.
>
> **5) ERROR**
>
> - 오류 메시지를 기록한다.
> - 심각한 문제 또는 예외 상황을 나타내며, 애플리케이션의 정상적인 동작에 영향을 미칠 수 있는 문제를 알린다.
>
> **6) FATAL**
>
> - 가장 심각한 오류 메시지를 기록한다.
> - 애플리케이션의 동작을 중단시킬 수 있는 치명적인 오류를 나타낸다.
> - 일반적으로 이러한 오류는 복구가 불가능하거나 매우 어려운 상황을 의미한다



### 2. 로그 출력 위치 지정

- System.out.println()는 출력 대상이 콘솔로 한정되어있지만, 로깅 프레임워크는 콘솔뿐만 아니라 파일 다양한 출력 대상으로 로그를 전송할 수 있습니다.

### 3. **성능 최적화**

- `System.out.println()`은 콘솔에 출력할 때 블로킹 I/O  작업을 수행합니다. 이는 시스템 성능에 악영향을 미칠 수 있습니다. 
- 반면 로깅 프레임워크는 버퍼링이나 비동기 로그 처리를 지원하여 성능 저하를 최소화할 수 있습니다.
- 또한, 필요하지 않은 로그 레벨은 출력되지 않도록 설정할 수 있어 불필요한 성능 비용을 줄일 수 있습니다

### 4. 커스텀 가능

- 로깅 프레임워크는 로그 메시지에 타임스탬프 , 스레드 정보, 클래스 및 메소드 이름 등 다양한 부가정보를 추가적으로 설정하여  로그의 가독성을 높이고 디버깅을 좀 더 쉽게 할 수있습니다.

### 

### 로깅 프레임워크의 종류

대표적으로 자바에서 사용하는 로깅 프레임워크에는 Log4j, Logback, Log4j2가 있습니다.

### log4j

- 가장 오래된 로깅 프레임워크로써 Apache의 Java기반 로깅 프레임워크 입니다.

- 2015년 기준으로 개발이 중단되었습니다.
- 콘솔 및 파일 출력의 형태로 로깅을 도와주며 xml, properties로 환경을 구성할 수 있습니다.



### logback

-  `log4j`의 아키텍쳐 기반으로 재작성 되었으며, java 기반 로깅 프레임워크입니다.
-  logback은 log4j보다 약 10배 더 빠르게 수행되도록 다시 작성되었습니다.
- logback 구성 요소는 log4j 보다 더 빠를 뿐만 아니라 메모리 사용량도 더 작습니다.



### log4j2

- Log4j의 업그레이드 버전이며, Logback의 아키텍처에 내재된 몇 가지 문제를 해결하면서 Logback에서 사용 가능한 많은 개선 사항을 제공합니다.

- 멀티스레드 시나리오에서 비동기 로거를 사용할 경우 Log4j 1.x 및 Logback보다 18배 더 높은 처리량과 수십 배 더 낮은 지연 시간을 제공합니다

- 메시지 로깅을 지원하고 람다표현식을 지원합니다. 

- Log4j는 기본적으로 gc free 모드에서 실행되며, 여기서 객체와 버퍼는 재사용되고 임시 객체는 가능한 한 할당되지 않습니다



### Log4j2를 사용하는 것을 권장합니다.

- 멀티스레드 환경에서 다른 라이브러리들에 비해서 압도적인 성능을 보여줍니다.
- 메시지 로깅과 Java8부터 도입된 람다식을 지원합니다.
- 기본적으로 가비지 프리 모드에서 실행되어집니다.

