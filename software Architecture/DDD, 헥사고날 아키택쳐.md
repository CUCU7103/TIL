# DDD, 헥사고날 아키텍쳐

### DDD란? (Domain Driven Design)

![image-20241208171234775](https://raw.githubusercontent.com/CUCU7103/save-image-repo/main/image/image-20241208171234775.png)

- 도메인 주도 설계(Domain-Driven Design, DDD)는 복잡한 소프트웨어 시스템을 설계할 때, 도메인의 복잡성을 관리하고, 비즈니스 요구사항을 효과적으로 반영하기 위한 소프트웨어 설계 접근 방식입니다.

1) **비즈니스 Domain별로 나누어 설계**하는 방식입니다. 

   - 기존의 어플리케이션 설계가 비즈니스 Domain에 대한 이해가 부족한 상태에서 설계 및 개발되었다는 반성에서 출발하였습니다. 

   - DDD에서는 기존의 현업에서 IT로의 일방향 소통구조를 탈피하여 **현업과 IT의 쌍방향 커뮤니케이션**을 매우 중요하게 생각합니다.

2) DDD의 **핵심 목표는 "Loosly coupling", "High cohesion"**입니다.
   - **높은 응집력**과 **낮은 결합도**로 도메인은 서로 독립적인 구조를 가지며, 변경과 확장에 용이한 설계를 하는것을 목표로 합니다.

3) DDD는 **Strategic Design과 Tactical Design**으로 나눌 수 있습니다. 
   - **Strategic Design은 개념 설계**이고 **Tactical Design**은 프로그래밍하기 위한 **구체적 설계**라고 할 수 있습니다.



### DDD의 계층 구조

![image-20241208170822591](https://raw.githubusercontent.com/CUCU7103/save-image-repo/main/image/image-20241208170822591.png)

일반적으로 4개의 계층 구조로 나뉘어진다.

- `Presentation Layer`(Controller)

  - 사용자 요청에 대해 해석하고 응답하는 일을 책임진다.
  - **즉, 클라이언트에게 요청을 받고 응답을 반환하는 역할을 하는 모든 클래스가 해당된다.**

- `Application Layer`(Service)

  - 비즈니스 로직을 정의하고 도메인 계층과 infrastructure 계층을 연결해주는 역할을 한다.
  - 많은 정보를 가지고 있지 않도록 하는 것이 좋다.
  - **실질적인 데이터 상태 변화 처리는 도메인 계층에서 진행할 수 있도록 한다.**

  Application Layer에서는 다음과 같은 기능들을 포함한다.

  1. 트랜잭션 단위
  2. DTO 변환
  3. 엔티티 조회/저장
     Entity를 찾고, 변경 내용 저장 기능을 호출한다. 구현은 Infrastructure Layer에서 구현한다.
  4. 사용자 인증/인가
     Presentation Layer에서 처리할 수 있는 url에 대한 인가 외에 다른 인가가 필요할 경우(DB와 대조 해야할 경우 등)
  5. 파라미터 검증
     Presentation Layer에서는 요청 방식에 따라 달라지는 '형식'에 대한 검증을 하고, Application Layer에서는 '논리' 오류를 검증한다.

- `Domain Layer`(Model)

  - 비즈니스 규칙/정보에 대한 실질적인 도메인에 대한 정보를 가지고 있으며, 모든 책임을 지는 계층이다.
  - **Entity를 활용한 도메인 로직이 실행되고, 업무 상황을 반영하여 상태를 제어하는 역할에 집중한다.**

- `Infrastructure Layer`(Repository)

  - 외부 통신(DB, 메시징 시스템)을 담당하는 계층이다.
  - **해당 계층에서 얻어온 정보를 Application Layer 또는 Domain Layer에 전달하는게 주 역할이다.**

  

## 도메인 주도 설계의 장점

- **비즈니스 도메인에 집중:**
  - DDD는 비즈니스 도메인을 중심으로 개발을 진행하는 방법론입니다. 
  - 개발자들은 도메인 전문가와 긴밀한 협력을 통해 비즈니스 도메인에 대한 이해를 깊이 있게 할 수 있습니다.
  - 이는 개발자들이 비즈니스 도메인의 복잡성을 이해하고 실제 요구사항을 반영하는 소프트웨어를 개발할 수 있도록 돕습니다.

- **의사소통과 협업의 강화:** 
  - DDD는 도메인 전문가와 개발자 간의 의사소통과 협업을 강화합니다. 비즈니스 도메인의 용어와 개념을 코드에 반영함으로써, 비즈니스 전문가와 개발자는 동일한 언어를 사용하여 서로간의 의사소통을 원활하게 할 수 있습니다.
  - 이는 비즈니스 요구사항을 명확하게 이해하고, 개발자들이 올바른 솔루션을 제공할 수 있도록 돕습니다.

- **유연하고 확장 가능한 설계:** 
  - DDD는 모델 주도 설계를 강조하므로, 소프트웨어 설계는 비즈니스 도메인 모델을 중심으로 이루어집니다. 
  - 이는 소프트웨어가 비즈니스 도메인을 잘 반영하고, 도메인의 복잡성을 다룰 수 있도록 합니다. 
  - 또한 도메인 모델은 지속적으로 발전하고 개선될 수 있으므로, 소프트웨어 시스템이 변화하는 요구사항에 유연하게 대응할 수 있습니다.

- **복잡성 관리:**
  - DDD는 복잡한 비즈니스 도메인을 모델링하는데 도움을 줍니다. 도메인 모델은 도메인의 핵심 개념과 규칙을 표현하므로 복잡한 비즈니스 도메인을 단순하고 이해하기 쉬운 구조로 변환할 수 있습니다. 이는 개발자들이 복잡성을 이해하고 제어하는데 도움을 주며 유지보수성을 향상시킵니다.

- **품질 향상:** 
  - DDD는 품질을 중요시하는 설계 원칙과 기법을 제공합니다. 도메인 모델을 통해 비즈니스 도메인의 핵심 개념과 규칙을 명확하게 표현할 수 있으며, 이를 기반으로 한 테스트 가능한 코드를 작성할 수 있습니다. 또한 DDD는 도메인 모델에 대한 테스트를 지원하는 다양한 도구와 패턴을 제공하여 품질 관리를 강화합니다.

 

- **마이크로서비스 아키텍처와의 결합:** 

  - DDD는 마이크로서비스 아키텍처와 자연스럽게 결합됩니다. 비즈니스 도메인을 기반으로 서비스를 분리하고 개별적으로 개발하고 배포함으로써, 마이크로서비스 아키텍처의 이점을 최대화할 수 있습니다. 

  - DDD는 마이크로서비스 간의 경계 설정과 상호작용을 명확하게 정의하고, 각 서비스를 독립적으로 발전시킬 수 있는 구조를 제공합니다.

    

## 도메인 주도 설계의 단점

**학습 곡선과 복잡성:** 

- DDD는 상대적으로 복잡한 개념과 패턴을 포함하고 있어 학습 곡선이 가파를 수 있습니다. \새로운 개념과 용어를 이해하고 적용하는 데 시간이 걸릴 수 있으며, 초기에는 설계 및 구현에 대한 추가적인 노력과 복잡성이 발생할 수 있습니다. 이는 팀의 경험 수준에 따라 영향을 받을 수 있습니다.

**과도한 추상화:*** 

- DDD는 도메인의 복잡성을 다루기 위해 추상화를 사용합니다.
- 하지만 과도한 추상화는 코드의 이해를 어렵게 하고 개발자들이 복잡한 구조를 해석하고 유지보수하는 데 어려움을 줄 수 있습니다. 
- 잘못된 추상화는 오히려 코드의 가독성을 저하시킬 수 있습니다.

 

**초기 비용과 시간:** 

- DDD는 비즈니스 도메인에 집중하는 설계 방법론으로, 초기에 도메인 모델을 개발하고 도메인 전문가와의 협업을 강조합니다. 
- 이는 초기 개발 비용과 시간을 증가시킬 수 있는데 특히, 도메인의 복잡성이 큰 경우에는 초기 분석과 설계에 많은 시간과 노력이 필요할 수 있습니다.

 

**팀 구성과 조직적인 도입 난이도:** 

- DDD는 도메인 전문가와 개발자 간의 협업을 강조하므로 팀의 구성이 중요합니다. 도메인 전문가와 개발자가 적절한 수준으로 협력하지 않는다면 DDD의 장점을 충분히 활용하기 어려울 수 있습니다. 
- 또한 기존 조직에서 DDD를 도입하려면 조직 문화와 프로세스의 변경이 필요할 수 있으며 이는 도입 난이도를 높일 수 있습니다.

 

**오용과 오버 엔지니어링:**

- DDD는 강력한 도구이지만 오용하면 과도한 복잡성과 오버 엔지니어링으로 이어질 수 있습니다. 적절한 상황과 도메인의 복잡성을 고려하지 않고 과도하게 DDD를 적용하면 개발 프로젝트의 비용과 일정을 증가시키고, 유지보수성을 저하시킬 수 있습니다. 

- DDD는 적절한 규모와 범위에서 적용해야 합니다.

  

**기술 종속성:** 

- DDD는 도메인 중심의 설계 방법론이지만, 특정 기술과 밀접하게 연결될 수 있습니다. 특히, DDD와 ORM(Object-Relational Mapping) 프레임워크를 함께 사용할 경우 기술 종속성이 커질 수 있습니다. 이는 기술 스택 변경이 어려워지고, 다른 환경에서의 적용이 제한될 수 있다는 점을 의미합니다.





# 헥사고날 아키텍쳐



![image-20241208172518600](https://raw.githubusercontent.com/CUCU7103/save-image-repo/main/image/image-20241208172518600.png)

### 헥사고날 아키텍쳐란?

- 소프트웨어 설계에 사용되는 아키텍쳐 패턴 중 하나로  여러 소프트웨어 환경에 쉽게 연결할 수 있도록 **느슨하게 결합된 애플리케이션 구성요소**를 만드는 것을 목표로 하는 아키텍쳐 입니다.

- 도메인의 비즈니스 로직을 외부 라이브러리 및 툴로부터 분리 할 때 포트와 어댑터라고 부르는 인터페이스를 사용하기 때문에 **포트&어댑터 아키텍처**라고도 부릅니다 



## 핵사고날 아키텍쳐의 구성

![image-20241208173213592](https://raw.githubusercontent.com/CUCU7103/save-image-repo/main/image/image-20241208173213592.png)

### 핵심 구성요소

#### **내부 영역 (도메인)**

- 순수한 비즈니스 로직이 포함된 캡슐화된 영역입니다
- 도메인 엔터티와 이와 상호작용하는 비즈니스 로직(UseCase)이 위치합니다
- 외부로 향하는 의존성이 없으며 모든 의존성이 이 코어를 향합니다

#### **외부 영역 (인프라)**

- 내부 영역에서 기술을 분리하여 구성한 영역입니다
- UI, 데이터베이스 등 외부 시스템과의 연동을 담당합니다

#### 포트와 어댑터

**포트**

- 포트는 application 입장에서 consumer, 또는 application에서 나가거나/들어오는 end point라고 볼 수 있습니다.

- 포트는 **내부 비즈니스 영역을 외부 영역에 노출한 API이고** 인바운드(Inbound) /아웃바운드(Outbound) 포트로 구분합니다.

- 인바운드 포트: 내부 영역 사용을 위해 노출된 API
- 아웃바운드 포트: 내부 영역이 외부 영역을 사용하기 위한 API

**어댑터**

- Primary(Driving) Adapter: **애플리케이션을 동작시키는 역할을 하며 주로 UI 부분이 포함**됩니다

- Secondary(Driven) Adapter: **애플리케이션에 의해 동작되는 역할을 하며 주로 인프라와 연결되는 부분입니다**

  



### **헥사고날 아키텍처 장단점**

**장점**

- 유연성 : 
  - 외부 시스템이나 인프라와의 의존성이 낮아 구성요소를 쉽게 교체하거나 업데이트가 가능
- 테스트 용이성 : 
  - 비즈니스 로직을 독립적으로 테스트할 수 있음
- 유지보수성 : 
  - 책임이 분리되어 있어 코드의 이해와 수정이 용이

**단점**

- 구현 복잡성 : 포트와 어댑터를 구성하고 관리하는데 복잡함
- 초기 개발 시간 증가





