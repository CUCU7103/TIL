# synchronized 단점 & java 에서 동시성 문제를 해결하기 위한 다른 방법



synchronized는 멀티스레드 환경에서 동시성 문제를 해결하기 위해 사용되어집니다. 

- 하지만 sychronized는  blocking 방식으로 동작하기에  `synchronized` 블록에 진입한 스레드는 해당 블록이 끝날 때까지 락을 유지하므로, 다른 스레드들은 대기해야 합니다.  
- 락은 특정 자원을 보호하기 위해 스레드가 해당 자원에 대한 접근하는 것을 제한합니다.
- 락이 걸려 있는 동안 다른 스레드들은 해당 자원에 접근할 수 없고, 락이 해제될 때까지 대기해야 합니다.
- 또한 락 기반 접근에서는 락을 획득하고 해제하는 데 시간이 소요됩니다.
- 이로 인해 병목 현상이 발생하여 성능이 저하된다는 단점이 있습니다.
- 또한 여러 스레드가 서로 다른 자원을 기다며 무한 대기 상태에 빠지는 데드락 상황이 발생할 수가 있습니다.



## 동시성 문제를 해결하는 다른 방법

## Atomic 클래스

- Atomic 클래스는 동시성 프로그래밍에서 **원자적(atomic)**인 연산을 제공하는 클래스들을 말합니다. 
- atomic 클래스 들은 내부적으로 Compare-And-Swap(CAS) 알고리즘을 사용하여 동기화 없이도 스레드 안전한 연산을 수행할 수 있습니다
- 이러한 특성 덕분에 Atomic 클래스는 **스레드 안전성**을 보장하면서도 **락(lock)**을 사용하지 않고 효율적으로 동기화를 구현할 수 있습니다

> [!NOTE]
>
> ### 원자적 연산
>
> - 중단되지 않고, 다른 연산과 간섭 없이 완전히 실행되거나 전혀 실행되지 않는 성질
> - 즉 멀티 스레드 상황에서 다른 스레드의 간섭없이 안전하게 처리되는 연산입니다.

> [!NOTE]
>
> ### CAS 알고리즘
>
> - "Compare and Swap"의 약자로, 동시성 프로그래밍에서 사용되는 원자적(atomic) 연산 중 하나입니다. 
> - 주로 멀티스레드 환경에서 데이터의 일관성을 유지하고, 동기화 문제를 해결하기 위해 사용됩니다
> - **메모리 주소**: 변경하고자 하는 데이터의 위치를 가리킵니다.
> - **기존 예상 값(Old Value)**: 현재 메모리 주소에 저장된 값으로 예상되는 값입니다.
> - **새로운 값(New Value)**: 메모리 주소에 저장하고자 하는 새로운 값입니다.
> - CAS 알고리즘은 다음과 같이 동작합니다.
>   1. **비교(Compare)**: 메모리의 특정 위치에 저장된 현재 값과 예상한 값을 비교합니다.
>   2. **교환(Swap)**: 현재 값이 예상한 값과 일치하면, 해당 메모리 위치의 값을 새로운 값으로 교체합니다.
> - **non-blocking 동작:** 락을 사용하지 않으므로, 스레드들이 대기하지 않고 동시에 연산을 수행할 수 있어 성능이 향상됩니다.
>
> - 멀티스레드 환경에서 여러 스레드가 동일한 변수를 증가시키는 상황을 가정해봅시다. 각 스레드는 다음과 같은 단계를 수행합니다:
>
>   1. **현재 값 읽기**: 변수의 현재 값을 읽습니다.
>   2. **새로운 값 계산**: 현재 값에 1을 더하여 새로운 값을 계산합니다.
>   3. **CAS 연산 수행**: 현재 값이 읽은 값과 동일한지 확인하고, 동일하다면 새로운 값으로 교체합니다.
>
>   이 과정에서, 만약 다른 스레드가 변수의 값을 변경하여 현재 값이 예상한 값과 다르다면, CAS 연산은 실패하고 스레드는 위 과정을 다시 시도합니다.
>
>   이를 통해 락을 사용하지 않고도 스레드 안전한 연산을 구현할 수 있습니다.



### 주요  Atomic 클래스 

- 공식문서 링크

https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html

**AtomicInteger**: `int` 타입의 값을 원자적으로 업데이트할 수 있는 클래스입니다.

```java
AtomicInteger atomicInt = new AtomicInteger(0);
atomicInt.incrementAndGet(); // 값 1 증가
```

**AtomicLong**: `long` 타입의 값을 원자적으로 업데이트할 수 있는 클래스입니다.

```java
AtomicLong atomicLong = new AtomicLong(0L);
atomicLong.addAndGet(10L); // 값 10 증가
```

**AtomicBoolean**: `boolean` 타입의 값을 원자적으로 업데이트할 수 있는 클래스입니다.

```java
AtomicBoolean atomicBool = new AtomicBoolean(false);
atomicBool.compareAndSet(false, true); // false에서 true로 변경
```

**AtomicReference<V>**: 객체 참조를 원자적으로 업데이트할 수 있는 클래스입니다.

```java
AtomicReference<String> atomicRef = new AtomicReference<>("초기값");
atomicRef.set("새값"); // 값 변경
```

**AtomicIntegerArray**, **AtomicLongArray**, **AtomicReferenceArray<E>**: 배열 형태의 값을 원자적으로 업데이트할 수 있는 클래스들입니다.


**Atomic 클래스의 동작 원리**

 Atomic 클래스들은 주로 **Compare and Swap(CAS)** 알고리즘을 내부적으로 사용하여 원자적 연산을 구현합니다. 

CAS는 앞서 설명한 대로, 특정 메모리 위치의 값을 기대 값과 비교한 후, 일치할 경우 새로운 값으로 교체하는 원자적 연산입니다. 이 과정을 통해 여러 스레드가 동시에 값을 업데이트하더라도 데이터의 일관성이 유지됩니다.

**Atomic 클래스의 장점**

- **높은 성능**: 락을 사용하지 않기 때문에 스레드 간의 컨텍스트 스위칭이나 대기 시간 없이 빠르게 연산을 수행할 수 있습니다.
- **락 프리(lock-free) 알고리즘**: 데드락(Deadlock)이나 라이브락(Livelock)과 같은 문제가 발생하지 않습니다.

**Atomic 클래스의 단점**

- **복잡한 연산의 한계**: 단순한 변수 업데이트에는 적합하지만, 복잡한 연산이나 여러 변수 간의 동기화가 필요한 경우에는 한계가 있습니다.
- **ABA 문제**: CAS는 값이 A에서 B로, 다시 A로 변경되는 경우를 감지하지 못합니다. 이는 특정 상황에서 문제를 일으킬 수 있습니다.

