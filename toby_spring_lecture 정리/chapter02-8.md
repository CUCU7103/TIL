## 개방폐쇄원칙(OCP)
- 클래스나 모듈은 확장에는 열려있어야 하고 변경에는 닫혀있어야 합니다.
- 어떤 클래스는 이 클래스의 기능을 확장할때 그 클래스의 코드는 변경되면 안된다.
- PaymentService에 적용되어져 있다.
  - paymentservice의 코드는 환율정보를 가져오는 방법이 변경되어질때 내부 코드의 변경이 일어나지 않습니다.
  - 즉 확장이 일어날때 자신의 코드는 변경되지 않습니다.

## 높은 응집도와 낮은 결합도

### 응집도
 - **응집도가 높다라는 것은 모듈이 하나의 책임 또는 관심사에 집중되어져 있다는 뜻**입니다.
   - 하나의 클래스가 하나의 관심사에 집중해야 한다.
   - 변화가 일어날 때 해당 모듈이나 클래스에서 변하는 부분이 커집니다.
   - 응집도가 커지면 변화가 일어날때 비용이 적게 듭니다.
   - 응집도가 낮으면 해당 모듈이나 클래스에서 변하는 부분이 아주 작은영역에서 발생합니다.
     - 응집도가 낮아서 하나의 모듈에서 변화가 일어날때 일부분만 바뀌면 나머지 부분에 문제가 없는지, 클래스가 수행하는 역할에 문제가 없는지 검증해야 한다.
   - ex) 기존에 api를 통해서 환율정보를 가져오는 방식에서, 회사 DB에서 가져오는 방식으로 통째로 변하는 것


### 결합도
  - 두 개 이상의 모듈,클래스가 서로 연결되어 있는 정도
  - 이에 따라서 서로 영향을 받는 것,
  - 느슨한 결합도를 유지하는 것이 바람직합니다.

![image](https://github.com/user-attachments/assets/59b5606f-4f5c-4a68-9aaa-d2bff03620a3)

 - 위의 그림에서 PaymentServive와 ExRateProvider 사이에는 분명하게 연결이 존재한다.
 - 하지만 결합도가 굉장히 낮다
 - 왜나하면 WebApi에서 Simple로 변경했을때 paymentServive에서 변경되는 부분이 없다.

### 전략패턴

- 자신의 기능 맥락(context)에서 필요에 따라서 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고
  이를 구현한 구체적인 알고리즘 클래스를 필요에 따라서 바꿔 사용할 수 있게하는 디자인 패턴입니다.
  
- 알고리즘을 대표하는 인터페이스를 정의해 놓고 구현할 클래스를 만들고 그 클래스의 오브젝트를 사용할지를 자기가 결정하는 대신에 앞에서 이 컨텍스에 해당하는 paymentService를 호출해주는 클라이언트가 주입시켜주는 방식을 사용해야 한다.

![image](https://github.com/user-attachments/assets/5dc62de4-8e02-4884-8fa2-ce7e2e8850e8)

위 그림에서 exrateProvider가 전략 인터페이스가 되고 하위 클래스 두 개가 전략을 구현한 클래스들이 되는 것이다.

```
public class Sort {

    public static void main(String[] args) {
        // List scores = Arrays.asList(5,7,1,8,9,2);
        List scores = Arrays.asList("z","b","spring","java");
        // 두 번째 인수를 교체하면서 정렬방식을 바꾸는 전형적인 전략패턴이다.
        Collections.sort(scores, (Comparator<String>) (o1, o2) -> o1.length() - o2.length());

        scores.forEach(System.out::println);
    }
}
```

### 제어의 역전 loc
- 제어권의 이전을 통한 제어관계역전
- 내가 권한을 가지고 하던 어떤 작업이 다른쪽으로 넘어갔다고 생각하면 편하다.












  
