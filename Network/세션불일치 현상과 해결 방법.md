# 세션불일치 현상과 해결 방법

- 서비스를 확장하기 위해서  서버를 scale-up과 scale-out 두 방식 중 한 개를 택하여 문제를 해결합니다

- 이때 단일 서버 환경에서는 session을 통한 로그인을 구할 때 session 불일치 문제를 신경쓸 필요가 없으나 scale-out으로 여러 대의 서버를 증설한다고 하면 session 불일치 문제가 발생합니다.

  - 여러 대의 **서버가 각각 세션 저장소를 독립적으로 갖기 때문에** 세션 불일치 문제가 발생하기 때문입니다.

    

- 세션 불일치 문제 예시

  ![image](https://github.com/user-attachments/assets/165ab10a-c45c-4d0e-9d3c-8eb429365570)


서비스를 사용하려는 사용자가 로그인했다는 상황을 가정해보겠습니다.



> [!NOTE]
>
> 로드벨런서란?
>
> - 클라이언트와 서버 Pool(서버 그룹들) **사이에 위치해서 서버의 부하를 분산시키는 하드웨어나 소프트웨어**를 의미합니다.
>   - 네트워크 트래픽과 클라이언트의 요청을 여러 서버에 적절하게 분배시킵니다.
>   - 정상적으로 운영되고 있는 서버에게만 요청을 전송합니다.
>   - 서비스의 직접적인 중단 없이 서버를 추가하거나 뺄 수 있습니다.



**1. 요청**

- 스케일 아웃의 경우 서버가 여러 대로 일을 나누어 처리하기 때문에, 로드밸런싱 전략을 통해 사용자의 요청이 여러 서버 중 하나의 서버로 전달됩니다.

**2. 세션 저장**

- 요청을 받은 서버를 `Server1`이라고 한다면, `Server1`에는 사용자의 로그인 정보가 담긴 세션이 저장됩니다.

**3. 로그인 성공**

- 해당 세션의 `sessionid`와 함께 로그인이 성공했다는 응답을 사용자에게 전달됩니다.

**4. 요청**

- 사용자가 서비스의 다른 기능을 사용하려고 요청을 보내면, 다시 로드밸런싱 전략에 의해 하나의 서버로 전달되는데, 이 때 사용자의 로그인 세션 정보가 존재하는 `Server1`으로 들어간다는 보장이 되지 않습니다.

**5. 세션 조회 실패**

- 세션이 저장된 서버 외의 다른 서버로 요청이 전달된다면 사용자가 요청 헤더에 넣은 `sessionid`로 조회가 불가능하기 때문에 로그인이 풀리는 현상이 발생합니다.





## 세션 불일치 문제를 해결하는 방법

### 1. Sticky Session

![image](https://github.com/user-attachments/assets/fd278e40-3d96-4190-9ea3-7894d15ac0b1)


![image](https://github.com/user-attachments/assets/e2310fad-1035-4e3e-886a-64efe58993c4)


- **Sticky Session**은 **사용자의 세션을 처음 생성한 서버가 해당 사용자의 작업을 담당하여 고정된 세션만 사용하는 전략**입니다.
- 즉, `User1`이 `Server1`에서 처음 로그인 요청을 하여 세션을 생성하였다면, 앞으로의 모든 `User1`의 요청은 `Server1`에만 보내지게 됩니다.
- 이렇게 특정 사용자의 요청을 하나의 서버로 고정시키기 위해서 로드밸런서는 요청을 보낸 사용자의 IP주소나 쿠키를 이용합니다. 
  - 응답은 Set cookie header에, 요청은 cookie 헤더에 서버의 정보를 담아서 보냅니다.
- IP tracking 또는 쿠키를 사용하는 방식으로 로드밸런서는 해당 사용자의 요청이 보내져야하는 고정된 서버를 확인하며, 그 후에 요청을 지정된 서버로 보냅니다.
- Sticky Session의 예시로 ELB(Elastic Load Balancing)를 들 수 있는데, 이것은 AWS(아마존 웹 서비스)에서 제공하는 로드밸런싱 서비스입니다. 
- 결론적으로 Sticky Session방식으로 사용자는 **세션이 유지되는 동안 하나의 서버만 사용하게 되므로 세션 불일치 문제가 발생하지 않습니다.**



### Sticky Session의 단점

<u>**1. 세션 정보를 잃어버릴 수 있다.**</u>

- **특정 서버에 장애가 발생하여 다운되면 해당 서버로 요청을 보내는 사용자의 세션 정보를 잃어버리게 됩니다**. 
- 로드밸런서는 트래픽을 다운된 서버를 제외하고 나머지 서버로 보내게 되는데, 결국 다시 로그인 해야하는 상황이 발생합니다. 
- 또, 다운된 서버가 다시 구동되더라도 이미 다른 서버로 분산된 세션 정보가 돌아오지 않아 다른 특정 서버에 트래픽이 집중될 수 있습니다.

**2. 특정 서버에 트래픽이 몰릴 수 있다.**

- **고정된 세션을 사용한다는 뜻은 사용자가 접속해야 하는 서버가 고정되어져 있기 때문에 하나의 서버에 트래픽이 집중될 수 있다는 위험성을 가지고 있습니다.**



#### 정리

- Sticky session에서는 사용자와 세션 정보를 갖고 있는 서버를 1:1로 매핑해주어 세션 불일치를 해결해지만, 

- 문제가 발생하면 Scale out의 장점인 트래픽 분산과 가용성을 제대로 활용하지 못하게 되는 경우가 발생할 수 있습니다.



## 2. Session Clustering

- **서버들을 하나의 클러스터로 묶어 관리하고, 클러스터 내의 서버들이 세션을 공유할 수 있도록 하는 방식입니다.**

- 클러스터링은 여러 대의 **컴퓨터 혹은 서버들이 연결되어 하나의 시스템처럼 동작하는 것을 의미합니다.** 

- WAS에 따라서 Session Clustering방식이 각각 다릅니다.

  - 스프링 부트의 내장 WAS인 Tomcat의 **Session Clustering** 방식은 다음과 같습니다.
    -

- ### **All-to-All Session Replication**

  - Tomcat은 Session Clustering을 구현하는 방법으로  All-to-All Session Replication 방식을 사용합니다.
  - **특정 서버에 생성된 세션을 클러스터를 이루는 모든 서버에 세션을 복제합니다.**
    
  ![image](https://github.com/user-attachments/assets/beaa1a27-1c3a-4246-b7d6-37aa0a1dfdab)

  - 사용자의 세션이 새로 생성되거나 업데이트 될 때마다 Tomcat에서 `DeltaManager`가 다른 모든 서버에 해당 세션의 정보를 복제합니다.
  - 그렇게 되면 사용자의 요청이 처음 세션을 생성한 서버가 아닌 다른 서버로 보내졌어도 모든 서버에는 사용자의 세션 정보를 가지고 있어 세션 불일치 문제가 발생하지 않습니다.

- ### **Primary-Secondary Session Replication**

![image](https://github.com/user-attachments/assets/c6596857-50da-4528-8f38-ff78cb85ee84)


- **Primay-Secondary 방식**은 Primary 서버의 세션 데이터를 **Secondary(Backup) 서버에만 전체 복제하여 저장**하는 방식으로, BackupManager 클래스를 통해 이 방식을 제공하고 있다.

- All-to-All Session Replication 방식은 그냥 무식하게 모든 서버에 복제하고 저장하는 것과 달리, Primary 서버와 Secondary(Backup) 서버에만 전체 세션을 복제하여 저장하되, 나머지 이외의 서버들에는 세션의 Key에 해당하는 **JSESSIONID만 복제**, 저장함으로써 **메모리를 절약**할 수 있는 방식이다.

- 하지만 만일 Primary, Secondary 서버를 제외한 다른 서버에 세션 정보를 요청할 경우 다시 온전한 세션 정보를 얻기 위해서는 Primary, Secondary에 다시 요청을 보내야한다는, 세션 복제를 위한 과정이 수행되는 문제점이 존재한다.



### 정리

- 이처럼 세션 클러스터링은 sticky 세션의 문제점인 특정 서버에만 트래픽이 몰리는 문제를 해결할 수 있었다.

- 그러나 세션 클러스터링이나 sticky 세션이나 **서버가 세션이라는 상태(데이터)를 가진다는 것**은 변함이 없다는 특징이 있다

- "서버가 상태(데이터)를 가진다"라는 의미는 Scale out 방식으로 확장을 했을 때 서버가 가지고 있는 데이터를 확장하는 서버에도 똑같이 맞춰줘야 한다는 뜻이다. 이는 곧 오버헤드로 이어진다.

- 정리하면, 세션 클러스터링은 정합성 이슈를 해결할 수 있지만, 성능적인 한계가 존재한다고 말 할 수 있다.



### Session Clustering의 단점

**1. 많은 메모리가 필요하다.**

- 서버마다 동일한 세션 정보를 가지고 있어야 되기 때문에, 서버가 확장될 수록 복제해야 할 세션 데이터가 늘어나고 이는 추가적인 오버헤드로 이어집니다.
  - Tomcat 공식문서에서는  4대 이상의 대규모 클러스터는 권장되지 않습니다.

**2. 성능 저하가 발생한다.**

- 마찬가지로 세션 데이터가 변경되면 모든 서버에 복제되므로 서버 수의 비례하여 네트워크 트래픽이 증가합니다
  -  그로인해 성능 저하가 발생할 수 있습니다.

**3. 세션 불일치 문제가 발생할 가능성이 존재한다.**

- **세션 데이터의 복제 작업 중에 모든 서버에 세션이 전파되기 까지의 시간차이로 인하여 세션 불일치 문제와 같은 예상치 못한 상황이 발생**할 수 있습니다.

**4. 새로운 서버가 생겨나면 클러스터링을 해주어야 한다.**

- 새로운 서버를 띄울 때마다 기존에 존재하던 WAS에 새로운 서버 IP/포트를 입력하여 클러스터링 해주어야 합니다. 
- 그로 인하여 새로운 서버를 띄우면 기존 서버의 수정이 발생하고, 에러가 생길 가능성도 생겨나게 됩니다.

## 3. Session Storage

- **Session Storage방식은 독립된 세션 저장소를 구성하여 해당 저장소에 세션 데이터를 저장하고, 여러 서버들이 이러한 독립된 세션 저장소에서 세션 데이터를 읽어와 세션 불일치를 해결하는 방식입니다.**

![image](https://github.com/user-attachments/assets/9a4e7a22-c2e6-4bae-8e54-90088300f32a)


- Session Storage가 분리되면 서버가 늘어나도 외부 저장소의 정보만 각각의 서버에 입력해주면 데이터를 읽어올 수 있습니다. 
- 새로운 서버를 추가하더라도 **추가한 서버에만 세션 저장소 정보를 명시하면 되기에 기존 서버의 수정이 발생하지 않습니다.**
- 세션을 저장할때 세션을 복제해 다른 서버들에 보낼 필요가 없어 **WAS끼리의 불필요한 네트워크 통신을 하지 않아도 됩니다.**
- 한 서버에 장애가 발생하더라도 세션은 이와 독립되어 별도로 존재하기 때문에 세션을 활용한 서비스에 영향을 미치지 않습니다.



## **Session Storage 종류**

**1. Disk Database (MySql, Oracle)**

- 세션 데이터를 디스크에 저장하는 방식입니다..

- 따라서 전원이 공급이 안되도 디스크에는 정보를 잃지 않고 잘 유지한다.

- 하지만 큰 단점이 하나 있는데 속도가 너무 느리다는 것이 맹점이다.


![image](https://github.com/user-attachments/assets/5ec6cf83-24c4-4010-8d23-60f229be4a5e)


**2. In-Memory (Redis / Memchached)**

- In-Memory는 데이터를 메모리에 저장하는 방식입니다.

- 그래서 I/O속도가 디스크와 비교해서 매우 빠르다.

- 하지만 전원이 공급되지 않으면 기억하고 있는 데이터를 모두 잃어버리게 됩니다.

![image](https://github.com/user-attachments/assets/8e893123-abba-448f-8073-86fdfaa94326)


세션 데이터는 보통 로그인에 많이 사용되며 일정 시간이 지나면 만료되도록 하는 것이 일반적이다 

즉 영구적인 저장보다는 빠른 입출력을 보장하는 In-memory에 저장하는 것이 좋다고 생각되어진다.



### Session Storage의 단점

- **세션 저장소가 다운되면 세션 정보를 잃어버릴 수 있다.**
  - 세션을 저장하고 있는 Session storage 자체에 장애가 발생할 경우 모든 세션을 잃어버려 세션을 사용하는 모든 서버에 영향이 끼치는 위험이 있다.
  - 동일한 세션 저장소를 하나 더 구성하여 복제해야 할 필요가 있습니다.
    - 마스터-슬레이브 복제



- **성능적인 마이너스**
  - 별도의 Session storage로부터 세션을 불러와야 하기 때문에 추가적인 네트워트 I/O가 발생한다는 점이다.
  - 세션을 외부에서 가져와 사용하기 때문에 로컬 메모리에 저장해 사용하는 것보다 성능적인 면에서 떨어질 수 밖에 없다.
