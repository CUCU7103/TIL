# Spring AOP 와 AspectJ

- AOP란?

  - 핵심적인 기능(비즈니스 로직)에서 부가적인 기능을 분리한 Aspect를 모듈화하여 개발하는 방법입니다.

  - AOP는 자바 어플리케이션 개발환경에서 웹 계층, 비즈니스 계층 등의 여러가지 레이어에서 나타나는 보안, 로깅 , 캐싱과 같은 공통적인 로직을 모듈화 하여 개발시 코드의 유지보수 및 간결화를 하기 위해 고안된 방법입니다.

  - 즉 횡단 관심사를 모듈화하는 프로그래밍 패러다임이라고 할 수있습니다.

    

## AOP의 주요 개념

AOP를 이해하기 위한 키워드 설명입니다.

1. **Aspect(애스펙트)**

   - ‘관심사(Concern)’를 모듈화한 것입니다.

   - 예: 로깅, 트랜잭션, 보안 등과 같이 공통 기능을 따로 모듈화하여 Aspect로 만듭니다.

     

2. **Advice(어드바이스)**

   - **실제로 어떤 로직이 수행되어야 하는지 정의한 코드 블록**입니다.

   - Aspect에 포함되며, 구체적인 부가 기능(로깅, 권한 체크 등)을 담고 있습니다.

   - 실행 시점에 따라 아래와 같이 구분됩니다.

     - Before: 메서드 실행 “직전”에 수행

     - After: 메서드 실행 “직후(성공/실패 불문)”에 수행

     - AfterReturning: 메서드가 “정상 종료”된 뒤에 수행

     - AfterThrowing: 메서드 실행 중 “예외 발생” 시 수행

     - Around: 메서드 호출 전후 전체를 감싸 수행

       

3. **Pointcut(포인트컷)**

   - Advice를 적용할 특정 지점(Join Point)을 “선택”하는 표현식입니다.

   - 예: 특정 클래스나 메서드에만 적용하고 싶을 때 해당 클래스·메서드 패턴을 지정합니다.

     

4. **Join Point(조인 포인트)**

   - Advice를 적용할 수 있는 “모든 지점”을 의미합니다.

   - 스프링 AOP에서는 주로 “메서드 호출 지점”을 Join Point로 다룹니다.

     

5. **Weaving(위빙)**

   - Aspect가 실제 코드에 “적용(삽입)”되는 과정을 가리킵니다.
   - 시점에 따라 컴파일 타임, 로드 타임, 런타임 위빙 등이 존재합니다.
   - 스프링 AOP는 주로 프록시를 이용해 런타임 위빙을 수행합니다.

---



### AOP의 장점

1. 관심사의 분리
   - 핵심 비즈니스 로직과 부가 기능(로깅, 보안, 트랜잭션 등)을 명확하게 분리하여 코드 가독성과 유지 보수성을 높입니다.
2. 중복 코드 제거
   - 여러 클래스나 메서드에 공통적으로 필요한 로직 (로깅, 히스토리 등등)이 한 곳(Aspect)에 모이므로 중복을 최소화할 수 있습니다.
3. 유지보수에 용이함
   - 공통 기능 변경 시 Aspect만 수정하면 되므로 수정 범위가 최소화 됩니다.



## Spring Aop 와  AspectJ의 차이점

### 스프링 aop

- 스프링 aop는 스프링 프레임 워크의 프록시 기반 aop입니다.
- @Aspect 애노테이션과 @Before, @After, @Around 등의 애노테이션을 사용해 Aspect를 작성합니다.
- 런타임에 프록시 객체가 생성되어 실제 대상 객체를 감싸고 있다가 설정된 포인트 컷에 해당하는 지점에 어드바이스를 실행합니다.

### AspectJ

- 자바 언어 차원에서 제공되는 aop 프레임워크 입니다.
- 컴파일 타임, 로드 타임 위빙을 지원하여 스프링 aop보다 더 다양한 조인 포인트에도 적용할 수있습니다.



### 적용범위의 차이

- #### 스프링 aop 

  - 메서드 레벨에서만 aop를 호출 할 수있습니다.

  - 주로 스프링 빈(Bean)에 대한 메서드 호출을 프록시로 감싸면서 Advice를 적용합니다

- #### AspectJ

  - 메서드 호출 뿐 아리나 생성자 호출 , 필드 접근 같은 다양한 지점에도 aop를 적용할 수 있습니다.

    

  즉 Spring AOP는 스프링 빈의 메서드 호출 시점에만 AOP를 적용하지만, AspectJ는 자바 언어 자체를 확장하여 훨씬 다양한 조인 포인트를 지원합니다.

---



### 위빙 방식의 차이

- **Spring AOP**
  - 주로 **런타임 위빙**(프록시 기반) 방식으로 AOP를 적용합니다.
  - 스프링이 런타임에 동적 프록시 또는 CGLIB 프록시를 생성해서 Advice 로직을 삽입합니다.

- **AspectJ**

  - **컴파일 타임, 로드 타임, 런타임** 모든 시점에 위빙이 가능합니다.

  - AspectJ 전용 컴파일러(`ajc`)를 사용하거나, 로드 타임 위빙(`LTW: Load-Time Weaving`) 등을 설정할 수 있습니다.

Spring AOP는 설정이 상대적으로 간단하지만, 기본적으로 런타임 프록시를 이용하는 반면, AspectJ는 언어 확장을 통해 컴파일 시점이나 클래스 로딩 시점에도 AOP 적용이 가능합니다.

---

## 성능과 확장성

- **Spring AOP**
  - 런타임 프록시를 생성하여 호출을 가로채므로, 메서드 호출 시마다 프록시 오버헤드가 발생합니다.
  - 대부분의 비즈니스 로직에서 큰 문제가 되지 않으나, 아주 빈번하게 호출되는 메서드에는 성능에 영향을 줄 수 있습니다.
- **AspectJ**
  - 컴파일 타임이나 로드 타임에 코드가 직접 삽입(위빙)되기 때문에, 호출 시점에는 프록시를 거치지 않아 **런타임 오버헤드가 매우 적습니다.**
  - 적용 범위가 넓고, 필드 접근 등 세밀한 제어가 가능하지만, 설정과 빌드 과정이 상대적으로 까다롭습니다.



## 결론

- **Spring AOP**는 스프링 프록시를 통한 **런타임 기반** AOP 구현으로, 손쉽게 AOP를 적용할 수 있고 유지 보수에도 유리합니다.
- **AspectJ**는 언어 레벨에서 지원되는 **강력한 AOP** 기능을 제공하며, 컴파일 타임/로드 타임 위빙을 통해 **성능 및 적용 범위**에서 우위를 가집니다.
- 단, AspectJ는 설정과 빌드 과정이 다소 복잡하고, 대부분의 일반적 요구사항(로깅, 트랜잭션)은 Spring AOP만으로도 충분한 경우가 많습니다.

> 

